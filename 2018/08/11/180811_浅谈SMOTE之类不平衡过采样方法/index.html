<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="机器学习,">










<meta name="description" content="本文是接着上篇MAHAKIL过采样方法写得。SMOTE方法算是现在比较流行的过采样方法了，其分为SMOTE-Regular, SMOTE-Borderline1, SMOTE-Borderline2, SMOTE-SVM这四种方法，应用非常广，而且效果也很好。本篇文章我将主要讲解SMOTE-Regular, SMOTE-Borderline1这两种方法（由于篇幅的原因）并给出相应源码，好了，废话不">
<meta name="keywords" content="机器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈SMOTE之类不平衡过采样方法">
<meta property="og:url" content="http://JackArch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/index.html">
<meta property="og:site_name" content="Deep  |  Mind">
<meta property="og:description" content="本文是接着上篇MAHAKIL过采样方法写得。SMOTE方法算是现在比较流行的过采样方法了，其分为SMOTE-Regular, SMOTE-Borderline1, SMOTE-Borderline2, SMOTE-SVM这四种方法，应用非常广，而且效果也很好。本篇文章我将主要讲解SMOTE-Regular, SMOTE-Borderline1这两种方法（由于篇幅的原因）并给出相应源码，好了，废话不">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180801.jpg">
<meta property="og:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180802.jpg">
<meta property="og:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180803.jpg">
<meta property="og:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180804.jpg">
<meta property="og:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180805.jpg">
<meta property="og:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180806.jpg">
<meta property="og:updated_time" content="2019-06-19T12:07:34.943Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈SMOTE之类不平衡过采样方法">
<meta name="twitter:description" content="本文是接着上篇MAHAKIL过采样方法写得。SMOTE方法算是现在比较流行的过采样方法了，其分为SMOTE-Regular, SMOTE-Borderline1, SMOTE-Borderline2, SMOTE-SVM这四种方法，应用非常广，而且效果也很好。本篇文章我将主要讲解SMOTE-Regular, SMOTE-Borderline1这两种方法（由于篇幅的原因）并给出相应源码，好了，废话不">
<meta name="twitter:image" content="http://jackarch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/pic/180801.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://JackArch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/">





  <title>浅谈SMOTE之类不平衡过采样方法 | Deep  |  Mind</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deep  |  Mind</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://JackArch.github.io/2018/08/11/180811_浅谈SMOTE之类不平衡过采样方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuangzhouzhishui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep  |  Mind">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">浅谈SMOTE之类不平衡过采样方法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-11T14:37:06+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文是接着上篇MAHAKIL过采样方法写得。SMOTE方法算是现在比较流行的过采样方法了，其分为SMOTE-Regular, SMOTE-Borderline1, SMOTE-Borderline2, SMOTE-SVM这四种方法，应用非常广，而且效果也很好。本篇文章我将主要讲解SMOTE-Regular, SMOTE-Borderline1这两种方法（由于篇幅的原因）并给出相应源码，好了，废话不说直接进正文。</p>
<p><strong>1 SMOTE-Regular算法详解</strong></p>
<p>在实际应用中，读者可能会碰到一种比较头疼的问题，那就是分类问题中类别型的因变量可能存在严重的偏倚，即类别之间的比例严重失调。如欺诈问题中，欺诈类观测在样本集中毕竟占少数;客户流失问题中，非忠实的客户往往也是占很少一部分;在某营销活动的响应问题中，真正参与活动的客户也同样只是少部分。</p>
<p>　　如果数据存在严重的不平衡，预测得出的结论往往也是有偏的，即分类结果会偏向于较多观测的类。对于这种问题该如何处理呢？最简单粗暴的办法就是构造1:1的数据，要么将多的那一类砍掉一部分（即欠采样），要么将少的那一类进行Bootstrap抽样（即过采样）。但这样做会存在问题，对于第一种方法，砍掉的数据会导致某些隐含信息的丢失;而第二种方法中，有放回的抽样形成的简单复制，又会使模型产生过拟合。</p>
<p>　　为了解决数据的非平衡问题，2002年Chawla提出了SMOTE算法，即合成少数过采样技术，它是基于随机过采样算法的一种改进方案。该技术是目前处理非平衡数据的常用手段，并受到学术界和工业界的一致认同，接下来简单描述一下该算法的理论思想。</p>
<p>　　SMOTE算法的基本思想就是对少数类别样本进行分析和模拟，并将人工模拟的新样本添加到数据集中，进而使原始数据中的类别不再严重失衡。该算法的模拟过程采用了KNN技术，模拟生成新样本的步骤如下：</p>
<p>　　采样最邻近算法，计算出每个少数类样本的K个近邻;</p>
<p>　　从K个近邻中随机挑选N个样本进行随机线性插值;</p>
<p>　　构造新的少数类样本;</p>
<p>　　将新样本与原数据合成，产生新的训练集;</p>
<p>Smote算法的思想其实很简单，先随机选定n个少类的样本，如下图</p>
<p><img src="./pic/180801.jpg" alt="img"></p>
<p>找出初始扩展的少类样本</p>
<p>再找出最靠近它的m个少类样本，如下图</p>
<p><img src="./pic/180802.jpg" alt="img"></p>
<p>再任选最临近的m个少类样本中的任意一点，</p>
<p><img src="./pic/180803.jpg" alt="img"></p>
<p>在这两点上任选一点，这点就是新增的数据样本</p>
<p>其实原理很简单，这么一说大家一看就知道了。它就是在少数类样本中用KNN方法合成了新样本，而不同于ROS方法随机复制成新样本，所以更具有代表性</p>
<p><strong>以下便是相应源码(SMOTE.py)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.neighbors import NearestNeighbors</span><br><span class="line">from base_sampler import *</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用K-近邻方法产生新样本</span><br><span class="line">def make_sample(old_feature_data, diff):</span><br><span class="line">    # 获取每一个少数类样本点周围最近的n_neighbors-1个点的位置矩阵</span><br><span class="line">    nns = NearestNeighbors(n_neighbors=6).fit(old_feature_data).kneighbors(old_feature_data, return_distance=False)[:,1:]</span><br><span class="line">    # 随机产生diff个随机数作为之后产生新样本的选取的样本下标值</span><br><span class="line">    samples_indices = np.random.randint(low=0, high=np.shape(old_feature_data)[0], size=diff)</span><br><span class="line">    # 随机产生diff个随机数作为之后产生新样本的间距值</span><br><span class="line">    steps = np.random.uniform(size=diff)</span><br><span class="line">    cols = np.mod(samples_indices, nns.shape[1])</span><br><span class="line">    reshaped_feature = np.zeros((diff, old_feature_data.shape[1]))</span><br><span class="line">    for i, (col, step) in enumerate(zip(cols, steps)):</span><br><span class="line">        row = samples_indices[i]</span><br><span class="line">        reshaped_feature[i] = old_feature_data[row] - step * (old_feature_data[row] - old_feature_data[nns[row, col]])</span><br><span class="line">    # 将原少数类样本点与新产生的少数类样本点整合</span><br><span class="line">    new_min_feature_data = np.vstack((reshaped_feature, old_feature_data))</span><br><span class="line">    return new_min_feature_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对不平衡的数据集imbalanced_data_arr2进行SMOTE采样操作，返回平衡数据集</span><br><span class="line"># :param imbalanced_data_arr2: 非平衡数据集</span><br><span class="line"># :return: 平衡后的数据集</span><br><span class="line">def SMOTE(imbalanced_data_arr2):</span><br><span class="line">    # 将数据集分开为少数类数据和多数类数据</span><br><span class="line">    minor_data_arr2, major_data_arr2 = seperate_minor_and_major_data(imbalanced_data_arr2)</span><br><span class="line">    # print(minor_data_arr2.shape)</span><br><span class="line">    # 计算多数类数据和少数类数据之间的数量差,也是需要过采样的数量</span><br><span class="line">    diff = major_data_arr2.shape[0] - minor_data_arr2.shape[0]</span><br><span class="line">    # 原始少数样本的特征集</span><br><span class="line">    old_feature_data = minor_data_arr2[:, : -1]</span><br><span class="line">    # 原始少数样本的标签值</span><br><span class="line">    old_label_data = minor_data_arr2[0][-1]</span><br><span class="line">    # 使用K近邻方法产生的新样本特征集</span><br><span class="line">    new_feature_data = make_sample(old_feature_data, diff)</span><br><span class="line">    # 使用K近邻方法产生的新样本标签数组</span><br><span class="line">    new_labels_data = np.array([old_label_data] * np.shape(major_data_arr2)[0])</span><br><span class="line">    # 将类别标签数组合并到少数类样本特征集，构建出新的少数类样本数据集</span><br><span class="line">    new_minor_data_arr2 = np.column_stack((new_feature_data, new_labels_data))</span><br><span class="line">    # print(new_minor_data_arr2[:,-1])</span><br><span class="line">    # 将少数类数据集和多数据类数据集合并，并对样本数据进行打乱重排，</span><br><span class="line">    balanced_data_arr2 = concat_and_shuffle_data(new_minor_data_arr2, major_data_arr2)</span><br><span class="line">    return balanced_data_arr2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    imbalanced_data = np.load(&apos;imbalanced_train_data_arr2.npy&apos;)</span><br><span class="line">    print(imbalanced_data.shape)</span><br><span class="line">    minor_data_arr2, major_data_arr2 = seperate_minor_and_major_data(imbalanced_data)</span><br><span class="line">    print(minor_data_arr2.shape)</span><br><span class="line">    print(major_data_arr2.shape)</span><br><span class="line">    # 测试SMOTE方法</span><br><span class="line">    balanced_data_arr2 = SMOTE(imbalanced_data)</span><br><span class="line">    print(balanced_data_arr2)</span><br><span class="line">    print(balanced_data_arr2.shape)</span><br></pre></td></tr></table></figure>

<p><strong>辅助类依旧是base_sampler.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;</span><br><span class="line">采样器的基础代码,可用于后面采样器的复用</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def seperate_minor_and_major_data(imbalanced_data_arr2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将训练数据分开为少数据类数据集和多数类数据集</span><br><span class="line">    :param imbalanced_data_arr2: 非平衡数集</span><br><span class="line">    :return: 少数据类数据集和多数类数据集</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 提取类别标签一维数组，并提取出两类类别标签标记</span><br><span class="line">    labels_arr1 = imbalanced_data_arr2[:, -1]</span><br><span class="line">    unique_labels_arr1 = np.unique(labels_arr1)</span><br><span class="line">    if len(unique_labels_arr1) != 2:</span><br><span class="line">        print(&apos;数据类别大于2，错误！&apos;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 找出少数类的类别标签</span><br><span class="line">    minor_label = unique_labels_arr1[0] if np.sum(labels_arr1 == unique_labels_arr1[0]) \</span><br><span class="line">                                           &lt; np.sum(labels_arr1 == unique_labels_arr1[1]) else unique_labels_arr1[1]</span><br><span class="line"></span><br><span class="line">    [rows, cols] = imbalanced_data_arr2.shape  # 获取数据二维数组形状</span><br><span class="line">    minor_data_arr2 = np.empty((0, cols))  # 建立一个空的少数类数据二维数组</span><br><span class="line">    major_data_arr2 = np.empty((0, cols))  # 建立一个空的多数类数据二维数组</span><br><span class="line"></span><br><span class="line">    # 遍历每个样本数据，分开少数类数据和多数类数据</span><br><span class="line">    for row in range(rows):</span><br><span class="line">        data_arr1 = imbalanced_data_arr2[row, :]</span><br><span class="line">        if data_arr1[-1] == minor_label:</span><br><span class="line">            # 如果类别标签为少数类类别标签，则将数据加入少数类二维数组中</span><br><span class="line">            minor_data_arr2 = np.row_stack((minor_data_arr2, data_arr1))</span><br><span class="line">        else:  # 否则，将数据加入多数类二维数组中</span><br><span class="line">            major_data_arr2 = np.row_stack((major_data_arr2, data_arr1))</span><br><span class="line"></span><br><span class="line">    return minor_data_arr2, major_data_arr2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def concat_and_shuffle_data(data1_arr2, data2_arr2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对两个numpy二维数组进行0轴连接，并对行向量进行打乱重排，</span><br><span class="line">    :param data1_arr2: numpy二维数组</span><br><span class="line">    :param data2_arr2: numpy二维数组</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data_arr2 = np.concatenate((data1_arr2, data2_arr2), axis=0)  # 数组0轴连接</span><br><span class="line">    np.random.shuffle(data_arr2)  # 行向量shuffle</span><br><span class="line">    return data_arr2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    imbalanced_train_data_path = &apos;../../data/clean_data/imbalanced_train_data_arr2.npy&apos;</span><br><span class="line">    imbalanced_train_data_arr2 = np.load(imbalanced_train_data_path)</span><br><span class="line">    minor_data_arr2, major_data_arr2 = seperate_minor_and_major_data(imbalanced_train_data_arr2)</span><br><span class="line">    print(minor_data_arr2.shape)</span><br><span class="line">    print(major_data_arr2.shape)</span><br></pre></td></tr></table></figure>

<p>以上便将SMOTE-Regular方法介绍完了，大家看完之后是不是觉得还意犹未尽啊，哈哈哈哈哈。别着急下面就给你来介绍SMOTE-Borderline1方法</p>
<p><strong>2 SMOTE-Borderline1算法详解</strong></p>
<p>如果说上面的方法你看懂了之后，那么这个方法你也很容易懂了。其实就是在SMOTE-Regular的基础上改进了一些，即选取的少数样本值集合会更小更具有代表性——在少数类与多数类样本的边缘。确定好之后产生新样本的步骤和SMOTE-Regular没什么区别，都是用选取的少数样本点与其他的距离其最近的少数样本点结合产生新样本（不知道这绕口令大家有没有听懂，哈哈哈哈哈，没听懂的话可以看看下面我贴的论文介绍片段）</p>
<p><img src="./pic/180804.jpg" alt="img"></p>
<p>SMOTE-Borderline简介</p>
<p>接下来就是贴出该方法的伪代码了，大家看仔细了哈</p>
<p><img src="./pic/180805.jpg" alt="img"></p>
<p><img src="./pic/180806.jpg" alt="img"></p>
<p>全英文的伪代码看完了，估计大家现在也晕晕乎乎的。尤其是对于英文不太好的朋友，别急，我这就把源码贴出来，对照源码看事半功倍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.neighbors import NearestNeighbors</span><br><span class="line">from sklearn.utils import safe_indexing</span><br><span class="line"></span><br><span class="line">from base_sampler import *</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 处于多数类与少数类边缘的样本</span><br><span class="line">def in_danger(imbalanced_featured_data, old_feature_data, old_label_data, imbalanced_label_data):</span><br><span class="line">    nn_m = NearestNeighbors(n_neighbors=11).fit(imbalanced_featured_data)</span><br><span class="line">    # 获取每一个少数类样本点周围最近的n_neighbors-1个点的位置矩阵</span><br><span class="line">    nnm_x = NearestNeighbors(n_neighbors=11).fit(imbalanced_featured_data).kneighbors(old_feature_data,</span><br><span class="line">                                                                                    return_distance=False)[:,1:]</span><br><span class="line">    nn_label = (imbalanced_label_data[nnm_x] != old_label_data).astype(int)</span><br><span class="line">    n_maj = np.sum(nn_label, axis=1)</span><br><span class="line">    return np.bitwise_and(n_maj &gt;= (nn_m.n_neighbors - 1) / 2, n_maj &lt; nn_m.n_neighbors - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 产生少数类新样本的方法</span><br><span class="line">def make_sample(imbalanced_data_arr2, diff):</span><br><span class="line">    # 将数据集分开为少数类数据和多数类数据</span><br><span class="line">    minor_data_arr2, major_data_arr2 = seperate_minor_and_major_data(imbalanced_data_arr2)</span><br><span class="line">    imbalanced_featured_data = imbalanced_data_arr2[:, : -1]</span><br><span class="line">    imbalanced_label_data = imbalanced_data_arr2[:, -1]</span><br><span class="line">    # 原始少数样本的特征集</span><br><span class="line">    old_feature_data = minor_data_arr2[:, : -1]</span><br><span class="line">    # 原始少数样本的标签值</span><br><span class="line">    old_label_data = minor_data_arr2[0][-1]</span><br><span class="line">    danger_index = in_danger(imbalanced_featured_data, old_feature_data, old_label_data, imbalanced_label_data)</span><br><span class="line">    # 少数样本中噪音集合，也就是最终要产生新样本的集合</span><br><span class="line">    danger_index_data = safe_indexing(old_feature_data, danger_index)</span><br><span class="line">    # 获取每一个少数类样本点周围最近的n_neighbors-1个点的位置矩阵</span><br><span class="line">    nns = NearestNeighbors(n_neighbors=6).fit(old_feature_data).kneighbors(danger_index_data,</span><br><span class="line">                                                                           return_distance=False)[:, 1:]</span><br><span class="line">    # 随机产生diff个随机数作为之后产生新样本的选取的样本下标值</span><br><span class="line">    samples_indices = np.random.randint(low=0, high=np.shape(danger_index_data)[0], size=diff)</span><br><span class="line">    # 随机产生diff个随机数作为之后产生新样本的间距值</span><br><span class="line">    steps = np.random.uniform(size=diff)</span><br><span class="line">    cols = np.mod(samples_indices, nns.shape[1])</span><br><span class="line">    reshaped_feature = np.zeros((diff, danger_index_data.shape[1]))</span><br><span class="line">    for i, (col, step) in enumerate(zip(cols, steps)):</span><br><span class="line">        row = samples_indices[i]</span><br><span class="line">        reshaped_feature[i] = danger_index_data[row] - step * (danger_index_data[row] - old_feature_data[nns[row, col]])</span><br><span class="line">    new_min_feature_data = np.vstack((reshaped_feature, old_feature_data))</span><br><span class="line">    return new_min_feature_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对不平衡的数据集imbalanced_data_arr2进行Border-SMOTE采样操作，返回平衡数据集</span><br><span class="line"># :param imbalanced_data_arr2: 非平衡数据集</span><br><span class="line"># :return: 平衡后的数据集</span><br><span class="line">def Border_SMOTE(imbalanced_data_arr2):</span><br><span class="line">    # 将数据集分开为少数类数据和多数类数据</span><br><span class="line">    minor_data_arr2, major_data_arr2 = seperate_minor_and_major_data(imbalanced_data_arr2)</span><br><span class="line">    # print(minor_data_arr2.shape)</span><br><span class="line">    # 计算多数类数据和少数类数据之间的数量差,也是需要过采样的数量</span><br><span class="line">    diff = major_data_arr2.shape[0] - minor_data_arr2.shape[0]</span><br><span class="line">    # 原始少数样本的标签值</span><br><span class="line">    old_label_data = minor_data_arr2[0][-1]</span><br><span class="line">    # 使用K近邻方法产生的新样本特征集</span><br><span class="line">    new_feature_data = make_sample(imbalanced_data_arr2, diff)</span><br><span class="line">    # 使用K近邻方法产生的新样本标签数组</span><br><span class="line">    new_labels_data = np.array([old_label_data] * np.shape(major_data_arr2)[0])</span><br><span class="line">    # 将类别标签数组合并到少数类样本特征集，构建出新的少数类样本数据集</span><br><span class="line">    new_minor_data_arr2 = np.column_stack((new_feature_data, new_labels_data))</span><br><span class="line">    # print(new_minor_data_arr2[:,-1])</span><br><span class="line">    # 将少数类数据集和多数据类数据集合并，并对样本数据进行打乱重排，</span><br><span class="line">    balanced_data_arr2 = concat_and_shuffle_data(new_minor_data_arr2, major_data_arr2)</span><br><span class="line">    return balanced_data_arr2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    imbalanced_data = np.load(&apos;imbalanced_train_data_arr2.npy&apos;)</span><br><span class="line">    print(imbalanced_data.shape)</span><br><span class="line">    minor_data_arr2, major_data_arr2 = seperate_minor_and_major_data(imbalanced_data)</span><br><span class="line">    print(minor_data_arr2.shape)</span><br><span class="line">    print(major_data_arr2.shape)</span><br><span class="line">    # 测试Border_SMOTE方法</span><br><span class="line">    balanced_data_arr2 = Border_SMOTE(imbalanced_data)</span><br><span class="line">    print(balanced_data_arr2.shape)</span><br></pre></td></tr></table></figure>

<p>辅助类代码和上面的base_sampler一样，这里就不在累赘了</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/24/180724_sklearn特征转换行为/" rel="next" title="sklearn特征转换行为">
                <i class="fa fa-chevron-left"></i> sklearn特征转换行为
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/16/180916_数据探索、特征选择、模型选择、交叉验证、模型融合/" rel="prev" title="数据探索.特征选择.模型选择.交叉验证.模型融合">
                数据探索.特征选择.模型选择.交叉验证.模型融合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhuangzhouzhishui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhuangzhouzhishui</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
